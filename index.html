<!DOCTYPE html>
<html>
<head>
  <title>AZ Tanks Online</title>
  <style>
    body { margin: 0; overflow: hidden; background: #222; }
    canvas { display: block; background: #333; }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const tankSize = 40;
    const bulletSize = 5;
    const tankSpeed = 3;
    const bulletSpeed = 7;
    const respawnTime = 200; // frames

    const walls = [
      // Outer boundaries with gaps
      { x: 0, y: 0, width: canvas.width / 3 - 40, height: 20 },
      { x: canvas.width / 3 + 40, y: 0, width: canvas.width * 2 / 3 - 80, height: 20 },
      { x: 0, y: canvas.height - 20, width: canvas.width / 2 - 40, height: 20 },
      { x: canvas.width / 2 + 40, y: canvas.height - 20, width: canvas.width / 2 - 40, height: 20 },
      { x: 0, y: 0, width: 20, height: canvas.height / 2 - 40 },
      { x: 0, y: canvas.height / 2 + 40, width: 20, height: canvas.height / 2 - 40 },
      { x: canvas.width - 20, y: 0, width: 20, height: canvas.height / 3 - 40 },
      { x: canvas.width - 20, y: canvas.height / 3 + 40, width: 20, height: canvas.height * 2 / 3 - 40 },

      // Maze-style internal walls with gaps for paths
      { x: 100, y: 160, width: 20, height: 160 },
      { x: 120, y: 160, width: 200, height: 20 },
      { x: 300, y: 180, width: 20, height: 160 },
      { x: 120, y: 320, width: 200, height: 20 },
      { x: 500, y: 200, width: 20, height: 200 },
      { x: 400, y: 380, width: 200, height: 20 },
      { x: 600, y: 100, width: 20, height: 180 },
      { x: 200, y: 500, width: 400, height: 20 },
      { x: 700, y: 300, width: 20, height: 200 },
      { x: 720, y: 300, width: 200, height: 20 },
      { x: 920, y: 300, width: 20, height: 200 },
      { x: 720, y: 480, width: 200, height: 20 }
    ];

    const tank1 = {
      spawnX: 50,
      spawnY: 50,
      x: 50,
      y: 50,
      color: "lime",
      keys: { left: "a", right: "d", up: "w", down: "s", shoot: " " },
      dx: 0,
      dy: 0,
      bullets: [],
      alive: true,
      respawnCounter: 0,
      kills: 0
    };

    const tank2 = {
      spawnX: canvas.width - 100,
      spawnY: canvas.height - 100,
      x: canvas.width - 100,
      y: canvas.height - 100,
      color: "red",
      keys: { left: "ArrowLeft", right: "ArrowRight", up: "ArrowUp", down: "ArrowDown", shoot: "/" },
      dx: 0,
      dy: 0,
      bullets: [],
      alive: true,
      respawnCounter: 0,
      kills: 0
    };

    const keysPressed = {};
    window.addEventListener("keydown", (e) => keysPressed[e.key] = true);
    window.addEventListener("keyup", (e) => keysPressed[e.key] = false);

    function rectsCollide(a, b) {
      return a.x < b.x + b.width && a.x + a.width > b.x && a.y < b.y + b.height && a.y + a.height > b.y;
    }

    function respawnTank(tank) {
      tank.x = tank.spawnX;
      tank.y = tank.spawnY;
      tank.bullets = [];
      tank.alive = true;
    }

    function updateTank(tank, opponent) {
      if (!tank.alive) {
        tank.respawnCounter--;
        if (tank.respawnCounter <= 0) respawnTank(tank);
        return;
      }

      tank.dx = 0;
      tank.dy = 0;
      if (keysPressed[tank.keys.left]) tank.dx = -tankSpeed;
      if (keysPressed[tank.keys.right]) tank.dx = tankSpeed;
      if (keysPressed[tank.keys.up]) tank.dy = -tankSpeed;
      if (keysPressed[tank.keys.down]) tank.dy = tankSpeed;

      let newX = tank.x + tank.dx;
      let newY = tank.y + tank.dy;

      const futureRect = { x: newX, y: newY, width: tankSize, height: tankSize };
      const collidesWall = walls.some(w => rectsCollide(futureRect, w));
      if (!collidesWall) {
        tank.x = newX;
        tank.y = newY;
      }

      if (keysPressed[tank.keys.shoot]) {
        if (!tank.shootCooldown) {
          tank.bullets.push({ x: tank.x + tankSize / 2, y: tank.y + tankSize / 2, dx: tank.dx * bulletSpeed || 0, dy: tank.dy * bulletSpeed || 0 });
          tank.shootCooldown = 20;
        }
      }
      if (tank.shootCooldown) tank.shootCooldown--;

      tank.bullets.forEach(b => {
        b.x += b.dx;
        b.y += b.dy;
      });

      tank.bullets = tank.bullets.filter(b => {
        const bulletRect = { x: b.x, y: b.y, width: bulletSize, height: bulletSize };
        const hitWall = walls.some(w => rectsCollide(bulletRect, w));
        const hitOpponent = opponent.alive && rectsCollide(bulletRect, { x: opponent.x, y: opponent.y, width: tankSize, height: tankSize });

        if (hitOpponent) {
          opponent.alive = false;
          opponent.respawnCounter = respawnTime;
          tank.kills++;
        }

        return !hitWall && b.x >= 0 && b.y >= 0 && b.x <= canvas.width && b.y <= canvas.height && !hitOpponent;
      });
    }

    function drawTank(tank) {
      if (!tank.alive) return;
      ctx.fillStyle = tank.color;
      ctx.fillRect(tank.x, tank.y, tankSize, tankSize);
      tank.bullets.forEach(b => {
        ctx.fillStyle = "white";
        ctx.fillRect(b.x, b.y, bulletSize, bulletSize);
      });
    }

    function drawWalls() {
      ctx.fillStyle = "white";
      walls.forEach(w => {
        ctx.fillRect(w.x, w.y, w.width, w.height);
      });
    }

    function drawHUD() {
      ctx.fillStyle = "lime";
      ctx.font = "20px Arial";
      ctx.fillText(`Green: ${tank1.kills} kills`, 20, 30);

      ctx.fillStyle = "red";
      ctx.fillText(`Red: ${tank2.kills} kills`, canvas.width - 180, 30);
    }

    function gameLoop() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawWalls();
      updateTank(tank1, tank2);
      updateTank(tank2, tank1);
      drawTank(tank1);
      drawTank(tank2);
      drawHUD();
      requestAnimationFrame(gameLoop);
    }

    gameLoop();
  </script>
</body>
</html>
